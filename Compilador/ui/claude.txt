void Compilacao(HWND hwnd) {
    // Limpar mensagens de erro anteriores
    SetWindowTextA(hErros, "");

    // Obter o comprimento do texto no controle de código
    int length = GetWindowTextLengthA(hCodigo);
    if (length == 0) {
        MessageBoxW(hwnd, L"Nenhum código para compilar.", L"Erro", MB_OK | MB_ICONERROR);
        return;
    }

    // Alocar buffer para o código
    char* codigo = (char*)malloc(length + 1);
    if (codigo == NULL) {
        MessageBoxW(hwnd, L"Erro de memória.", L"Erro", MB_OK | MB_ICONERROR);
        return;
    }

    // Ler o texto do controle de código
    GetWindowTextA(hCodigo, codigo, length + 1);

    // Criar um arquivo temporário para a compilação
    FILE* fp = tmpfile();
    if (fp == NULL) {
        free(codigo);
        MessageBoxW(hwnd, L"Erro ao criar arquivo temporário.", L"Erro", MB_OK | MB_ICONERROR);
        return;
    }

    // Escrever o código no arquivo temporário
    fwrite(codigo, 1, length, fp);
    rewind(fp);

    // Liberar o buffer de código
    free(codigo);

    // Preparar variáveis para análise sintática
    char erro[1024] = {0};
    token main_tk;
    int linha_main = 1;

    // Configurar handler de saída para limpeza de memória
    atexit(limpa_memoria);

    // Definir o primeiro caractere
    caractere = fgetc(fp);

    // Realizar análise sintática
    AnalisadorSintatico(fp, &linha_main, &main_tk);

    // Fechar arquivo temporário
    fclose(fp);

    // Verificar se há erros
    if (strlen(erro) > 0) {
        // Exibir erros no controle de erros
        SetWindowTextA(hErros, erro);
    } else {
        // Se não houver erros, mostrar mensagem de sucesso
        SetWindowTextA(hErros, "Compilação concluída com sucesso!");
    }
}